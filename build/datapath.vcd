$date
	Thu Jul 14 22:05:30 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module DatapathTB $end
$var reg 1 ! clock $end
$var reg 1 " reset $end
$scope module datapath $end
$var wire 1 ! clock $end
$var wire 32 # immediateSH [31:0] $end
$var wire 1 " reset $end
$var wire 1 $ zero $end
$var wire 32 % writeData [31:0] $end
$var wire 32 & readData [31:0] $end
$var wire 1 ' rWrite $end
$var wire 1 ( memtoReg $end
$var wire 1 ) memWrite $end
$var wire 1 * memRead $end
$var wire 32 + instruction [31:0] $end
$var wire 32 , immediate [31:0] $end
$var wire 32 - data2 [31:0] $end
$var wire 32 . data1 [31:0] $end
$var wire 1 / branch $end
$var wire 32 0 auxiliarData [31:0] $end
$var wire 32 1 PCshift [31:0] $end
$var wire 32 2 PCpsadd [31:0] $end
$var wire 32 3 PCNext [31:0] $end
$var wire 32 4 PC [31:0] $end
$var wire 32 5 ALUout [31:0] $end
$var wire 1 6 ALUSrc $end
$var wire 2 7 ALUOp [1:0] $end
$var wire 4 8 ALUCrt [3:0] $end
$scope module alu $end
$var wire 1 ! clock $end
$var wire 32 9 input2 [31:0] $end
$var wire 32 : input1 [31:0] $end
$var wire 4 ; ALUControl [3:0] $end
$var reg 32 < ALUOut [31:0] $end
$var reg 1 $ zero $end
$upscope $end
$scope module aluCrt $end
$var wire 1 ! clock $end
$var wire 3 = funct3 [2:0] $end
$var wire 7 > funct7 [6:0] $end
$var wire 2 ? ALUOp [1:0] $end
$var reg 4 @ outALUControl [3:0] $end
$upscope $end
$scope module control $end
$var wire 1 ! clock $end
$var wire 7 A opcode [6:0] $end
$var reg 2 B ALUOp [1:0] $end
$var reg 1 6 ALUSrc $end
$var reg 1 / branch $end
$var reg 1 * memoryRead $end
$var reg 1 ( memoryToRegister $end
$var reg 1 ) memoryWrite $end
$var reg 1 ' rWrite $end
$upscope $end
$scope module dataMem $end
$var wire 1 ! clock $end
$var wire 1 ) memRead $end
$var wire 1 * memWrite $end
$var wire 32 C position [31:0] $end
$var wire 1 " reset $end
$var wire 32 D writeData [31:0] $end
$var reg 32 E readData [31:0] $end
$upscope $end
$scope module immGen $end
$var wire 1 ! clock $end
$var wire 32 F immediate [31:0] $end
$var reg 32 G outImmediate [31:0] $end
$upscope $end
$scope module instructionMem $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 32 H PC [31:0] $end
$var reg 32 I out [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 1 ! clock $end
$var wire 32 J input2 [31:0] $end
$var wire 1 6 selector $end
$var wire 32 K input1 [31:0] $end
$var reg 32 L out [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 1 ! clock $end
$var wire 32 M input1 [31:0] $end
$var wire 32 N input2 [31:0] $end
$var wire 1 ( selector $end
$var reg 32 O out [31:0] $end
$upscope $end
$scope module mux32And $end
$var wire 1 / branch $end
$var wire 1 ! clock $end
$var wire 1 $ zero $end
$var wire 32 P addPCShift [31:0] $end
$var wire 32 Q addPC [31:0] $end
$var reg 32 R PCNext [31:0] $end
$var reg 1 S selector $end
$upscope $end
$scope module pcAdd $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 32 T outPCNext [31:0] $end
$var reg 32 U outPCAdder [31:0] $end
$upscope $end
$scope module pcAdderShift $end
$var wire 1 ! clock $end
$var wire 32 V immediate [31:0] $end
$var wire 1 " reset $end
$var wire 32 W outPCNext [31:0] $end
$var reg 32 X PCAddShift [31:0] $end
$upscope $end
$scope module programCounter $end
$var wire 32 Y PCNext [31:0] $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var reg 32 Z outPCNext [31:0] $end
$upscope $end
$scope module registerMem $end
$var wire 1 ! clock $end
$var wire 32 [ dataWrite [31:0] $end
$var wire 1 ' rWrite $end
$var wire 1 " reset $end
$var wire 5 \ rs1 [4:0] $end
$var wire 5 ] rs2 [4:0] $end
$var wire 5 ^ rsWrite [4:0] $end
$var reg 32 _ outRS1 [31:0] $end
$var reg 32 ` outRS2 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx `
bx _
bx ^
bx ]
bx \
bx [
b0 Z
bx Y
bx X
b0 W
bz V
bx U
b0 T
xS
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
b0 H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
x6
bx 5
bx 4
b0 3
bx 2
bx 1
bx 0
x/
bx .
bx -
bx ,
bx +
x*
x)
x(
x'
bx &
bx %
x$
bz #
0"
0!
$end
#20000
b0 =
b0 >
b10 ^
b1 ]
b0 \
b110011 A
bx 3
bx H
bx T
bx W
bx Z
b100000000000100110011 +
b100000000000100110011 F
b100000000000100110011 I
1$
b100 2
b100 Q
b100 U
b0 5
b0 <
b0 C
b0 N
0S
1!
#40000
0!
#60000
bx =
bx >
bx ^
bx ]
bx \
bx A
b10 8
b10 ;
b10 @
b0 -
b0 K
b0 `
b0 .
b0 :
b0 _
bx +
bx F
bx I
b10 7
b10 ?
b10 B
0/
0)
0*
1'
0(
06
bx 2
bx Q
bx U
1!
#80000
0!
#100000
bx -
bx K
bx `
bx .
bx :
bx _
b0 0
b0 9
b0 L
0$
bx 5
bx <
bx C
bx N
1!
#120000
0!
#140000
bx 0
bx 9
bx L
1!
#160000
0!
#180000
1!
#200000
0!
#220000
1!
#240000
0!
#260000
1!
#280000
0!
#300000
1!
#320000
0!
#340000
1!
#360000
0!
#380000
1!
#400000
0!
#420000
1!
#440000
0!
#460000
1!
#480000
0!
#500000
1!
#520000
0!
#540000
1!
#560000
0!
#580000
1!
#600000
0!
#620000
1!
#640000
0!
