$date
	Thu Jul 14 23:14:53 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module DatapathTB $end
$var reg 1 ! clock $end
$var reg 1 " reset $end
$scope module datapath $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 1 # zero $end
$var wire 32 $ writeData [31:0] $end
$var wire 32 % readData [31:0] $end
$var wire 1 & rWrite $end
$var wire 1 ' memtoReg $end
$var wire 1 ( memWrite $end
$var wire 1 ) memRead $end
$var wire 32 * instruction [31:0] $end
$var wire 32 + immediate [31:0] $end
$var wire 32 , data2 [31:0] $end
$var wire 32 - data1 [31:0] $end
$var wire 1 . branch $end
$var wire 32 / auxiliarData [31:0] $end
$var wire 32 0 PCshift [31:0] $end
$var wire 32 1 PCpsadd [31:0] $end
$var wire 32 2 PCNext [31:0] $end
$var wire 32 3 PC [31:0] $end
$var wire 32 4 ALUout [31:0] $end
$var wire 1 5 ALUSrc $end
$var wire 2 6 ALUOp [1:0] $end
$var wire 4 7 ALUCrt [3:0] $end
$scope module alu $end
$var wire 1 ! clock $end
$var wire 32 8 input2 [31:0] $end
$var wire 32 9 input1 [31:0] $end
$var wire 4 : ALUControl [3:0] $end
$var reg 32 ; ALUOut [31:0] $end
$var reg 1 # zero $end
$upscope $end
$scope module aluCrt $end
$var wire 1 ! clock $end
$var wire 3 < funct3 [2:0] $end
$var wire 7 = funct7 [6:0] $end
$var wire 2 > ALUOp [1:0] $end
$var reg 4 ? outALUControl [3:0] $end
$upscope $end
$scope module control $end
$var wire 1 ! clock $end
$var wire 7 @ opcode [6:0] $end
$var reg 2 A ALUOp [1:0] $end
$var reg 1 5 ALUSrc $end
$var reg 1 . branch $end
$var reg 1 ) memoryRead $end
$var reg 1 ' memoryToRegister $end
$var reg 1 ( memoryWrite $end
$var reg 1 & rWrite $end
$upscope $end
$scope module dataMem $end
$var wire 1 ! clock $end
$var wire 1 ( memRead $end
$var wire 1 ) memWrite $end
$var wire 32 B position [31:0] $end
$var wire 1 " reset $end
$var wire 32 C writeData [31:0] $end
$var reg 32 D readData [31:0] $end
$upscope $end
$scope module immGen $end
$var wire 1 ! clock $end
$var wire 32 E immediate [31:0] $end
$var reg 32 F outImmediate [31:0] $end
$upscope $end
$scope module instructionMem $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 32 G PC [31:0] $end
$var reg 32 H out [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 1 ! clock $end
$var wire 32 I input2 [31:0] $end
$var wire 1 5 selector $end
$var wire 32 J input1 [31:0] $end
$var reg 32 K out [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 1 ! clock $end
$var wire 32 L input1 [31:0] $end
$var wire 32 M input2 [31:0] $end
$var wire 1 ' selector $end
$var reg 32 N out [31:0] $end
$upscope $end
$scope module mux32And $end
$var wire 1 . branch $end
$var wire 1 ! clock $end
$var wire 1 # zero $end
$var wire 32 O addPCShift [31:0] $end
$var wire 32 P addPC [31:0] $end
$var reg 32 Q PCNext [31:0] $end
$var reg 1 R selector $end
$upscope $end
$scope module pcAdd $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 32 S outPCNext [31:0] $end
$var reg 32 T outPCAdder [31:0] $end
$upscope $end
$scope module pcAdderShift $end
$var wire 1 ! clock $end
$var wire 32 U immediate [31:0] $end
$var wire 1 " reset $end
$var wire 32 V outPCNext [31:0] $end
$var reg 32 W PCAddShift [31:0] $end
$upscope $end
$scope module programCounter $end
$var wire 32 X PCNext [31:0] $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var reg 32 Y outPCNext [31:0] $end
$upscope $end
$scope module registerMem $end
$var wire 1 ! clock $end
$var wire 32 Z dataWrite [31:0] $end
$var wire 1 & rWrite $end
$var wire 1 " reset $end
$var wire 5 [ rs1 [4:0] $end
$var wire 5 \ rs2 [4:0] $end
$var wire 5 ] rsWrite [4:0] $end
$var reg 32 ^ outRS1 [31:0] $end
$var reg 32 _ outRS2 [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx _
bx ^
bx ]
bx \
bx [
bx Z
b0 Y
bx X
bx W
b0 V
bx U
bx T
b0 S
xR
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
b0 G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
x5
bx 4
bx 3
b0 2
bx 1
bx 0
bx /
x.
bx -
bx ,
bx +
bx *
x)
x(
x'
x&
bx %
bx $
x#
0"
0!
$end
#20000
b0 <
b0 =
b10 ]
b1 \
b0 [
b110011 @
bx 2
bx G
bx S
bx V
bx Y
b100000000000100110011 *
b100000000000100110011 E
b100000000000100110011 H
1#
b100 1
b100 P
b100 T
b0 4
b0 ;
b0 B
b0 M
0R
1!
#40000
0!
#60000
bx <
bx =
bx ]
bx \
bx [
bx @
b10 7
b10 :
b10 ?
b0 ,
b0 C
b0 J
b0 _
b0 -
b0 9
b0 ^
bx *
bx E
bx H
b10 6
b10 >
b10 A
0.
0(
0)
1&
0'
05
bx 1
bx P
bx T
1!
#80000
0!
#100000
bx ,
bx C
bx J
bx _
bx -
bx 9
bx ^
b0 /
b0 8
b0 K
0#
bx 4
bx ;
bx B
bx M
1!
#120000
0!
#140000
bx /
bx 8
bx K
1!
#160000
0!
#180000
1!
#200000
0!
#220000
1!
#240000
0!
#260000
1!
#280000
0!
#300000
1!
#320000
0!
#340000
1!
#360000
0!
#380000
1!
#400000
0!
#420000
1!
#440000
0!
#460000
1!
#480000
0!
#500000
1!
#520000
0!
#540000
1!
#560000
0!
#580000
1!
#600000
0!
#620000
1!
#640000
0!
