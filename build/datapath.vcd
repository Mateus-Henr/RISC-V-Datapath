$date
	Wed Jul 06 20:56:44 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module DatapathTB $end
$var wire 32 ! registerArray9 [31:0] $end
$var wire 32 " registerArray8 [31:0] $end
$var wire 32 # registerArray7 [31:0] $end
$var wire 32 $ registerArray6 [31:0] $end
$var wire 32 % registerArray5 [31:0] $end
$var wire 32 & registerArray4 [31:0] $end
$var wire 32 ' registerArray32 [31:0] $end
$var wire 32 ( registerArray31 [31:0] $end
$var wire 32 ) registerArray30 [31:0] $end
$var wire 32 * registerArray3 [31:0] $end
$var wire 32 + registerArray29 [31:0] $end
$var wire 32 , registerArray28 [31:0] $end
$var wire 32 - registerArray27 [31:0] $end
$var wire 32 . registerArray26 [31:0] $end
$var wire 32 / registerArray25 [31:0] $end
$var wire 32 0 registerArray24 [31:0] $end
$var wire 32 1 registerArray23 [31:0] $end
$var wire 32 2 registerArray22 [31:0] $end
$var wire 32 3 registerArray21 [31:0] $end
$var wire 32 4 registerArray20 [31:0] $end
$var wire 32 5 registerArray2 [31:0] $end
$var wire 32 6 registerArray19 [31:0] $end
$var wire 32 7 registerArray18 [31:0] $end
$var wire 32 8 registerArray17 [31:0] $end
$var wire 32 9 registerArray16 [31:0] $end
$var wire 32 : registerArray15 [31:0] $end
$var wire 32 ; registerArray14 [31:0] $end
$var wire 32 < registerArray13 [31:0] $end
$var wire 32 = registerArray12 [31:0] $end
$var wire 32 > registerArray11 [31:0] $end
$var wire 32 ? registerArray10 [31:0] $end
$var wire 32 @ registerArray1 [31:0] $end
$var wire 32 A line [31:0] $end
$var reg 1 B clock $end
$var reg 1 C reset $end
$scope module datapath $end
$var wire 32 D ALUoperator [31:0] $end
$var wire 32 E ALUrResp [31:0] $end
$var wire 32 F PC [31:0] $end
$var wire 1 B clock $end
$var wire 1 C reset $end
$var wire 1 G zero $end
$var wire 32 H writeData [31:0] $end
$var wire 32 I registerArray9 [31:0] $end
$var wire 32 J registerArray8 [31:0] $end
$var wire 32 K registerArray7 [31:0] $end
$var wire 32 L registerArray6 [31:0] $end
$var wire 32 M registerArray5 [31:0] $end
$var wire 32 N registerArray4 [31:0] $end
$var wire 32 O registerArray32 [31:0] $end
$var wire 32 P registerArray31 [31:0] $end
$var wire 32 Q registerArray30 [31:0] $end
$var wire 32 R registerArray3 [31:0] $end
$var wire 32 S registerArray29 [31:0] $end
$var wire 32 T registerArray28 [31:0] $end
$var wire 32 U registerArray27 [31:0] $end
$var wire 32 V registerArray26 [31:0] $end
$var wire 32 W registerArray25 [31:0] $end
$var wire 32 X registerArray24 [31:0] $end
$var wire 32 Y registerArray23 [31:0] $end
$var wire 32 Z registerArray22 [31:0] $end
$var wire 32 [ registerArray21 [31:0] $end
$var wire 32 \ registerArray20 [31:0] $end
$var wire 32 ] registerArray2 [31:0] $end
$var wire 32 ^ registerArray19 [31:0] $end
$var wire 32 _ registerArray18 [31:0] $end
$var wire 32 ` registerArray17 [31:0] $end
$var wire 32 a registerArray16 [31:0] $end
$var wire 32 b registerArray15 [31:0] $end
$var wire 32 c registerArray14 [31:0] $end
$var wire 32 d registerArray13 [31:0] $end
$var wire 32 e registerArray12 [31:0] $end
$var wire 32 f registerArray11 [31:0] $end
$var wire 32 g registerArray10 [31:0] $end
$var wire 32 h registerArray1 [31:0] $end
$var wire 1 i regWrite $end
$var wire 32 j readData [31:0] $end
$var wire 1 k memtoReg $end
$var wire 1 l memWrite $end
$var wire 1 m memRead $end
$var wire 32 n instruction [31:0] $end
$var wire 32 o immediateSH [31:0] $end
$var wire 32 p immediate [31:0] $end
$var wire 32 q data2 [31:0] $end
$var wire 32 r data1 [31:0] $end
$var wire 1 s branch $end
$var wire 32 t auxiliarData [31:0] $end
$var wire 32 u PCshift [31:0] $end
$var wire 32 v PCpsadd [31:0] $end
$var wire 32 w PCNext [31:0] $end
$var wire 32 x ALUout [31:0] $end
$var wire 1 y ALUSrc $end
$var wire 2 z ALUOp [1:0] $end
$var wire 4 { ALUCrt [3:0] $end
$scope module alu $end
$var wire 32 | input2 [31:0] $end
$var wire 32 } input1 [31:0] $end
$var wire 4 ~ ALUControl [3:0] $end
$var reg 32 !" ALUOut [31:0] $end
$var reg 1 G zero $end
$scope function sOut $end
$var reg 32 "" input1 [31:0] $end
$var reg 32 #" input2 [31:0] $end
$upscope $end
$upscope $end
$scope module aluCrt $end
$var wire 3 $" funct3 [2:0] $end
$var wire 7 %" funct7 [6:0] $end
$var wire 2 &" ALUOp [1:0] $end
$var reg 4 '" outALUControl [3:0] $end
$upscope $end
$scope module control $end
$var wire 7 (" opcode [6:0] $end
$var reg 2 )" ALUOp [1:0] $end
$var reg 1 y ALUSrc $end
$var reg 1 s branch $end
$var reg 1 m memoryRead $end
$var reg 1 k memoryToRegister $end
$var reg 1 l memoryWrite $end
$var reg 1 i regWrite $end
$upscope $end
$scope module dataMem $end
$var wire 32 *" address [31:0] $end
$var wire 1 B clock $end
$var wire 1 l memRead $end
$var wire 1 m memWrite $end
$var wire 1 C reset $end
$var wire 32 +" writeData [31:0] $end
$var reg 32 ," readData [31:0] $end
$upscope $end
$scope module immGen $end
$var wire 32 -" opcode [31:0] $end
$var wire 32 ." immediate [31:0] $end
$var wire 3 /" funct3 [2:0] $end
$var reg 32 0" outImmediate [31:0] $end
$upscope $end
$scope module instructionMem $end
$var wire 1 B clock $end
$var wire 1 C reset $end
$var wire 32 1" PC [31:0] $end
$var reg 32 2" out [31:0] $end
$upscope $end
$scope module mux1 $end
$var wire 32 3" input2 [31:0] $end
$var wire 1 y selector $end
$var wire 32 4" input1 [31:0] $end
$var reg 32 5" out [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 32 6" input1 [31:0] $end
$var wire 32 7" input2 [31:0] $end
$var wire 1 k selector $end
$var reg 32 8" out [31:0] $end
$upscope $end
$scope module mux32And $end
$var wire 1 s branch $end
$var wire 1 G zero $end
$var wire 32 9" addPCShift [31:0] $end
$var wire 32 :" addPC [31:0] $end
$var reg 32 ;" PCNext [31:0] $end
$var reg 1 <" selector $end
$upscope $end
$scope module pcAdd $end
$var event 1 =" _ivl_0 $end
$var wire 32 >" PC [31:0] $end
$var reg 32 ?" outPCAdder [31:0] $end
$upscope $end
$scope module pcAdderShift $end
$var wire 32 @" immediate [31:0] $end
$var wire 32 A" PC [31:0] $end
$var reg 32 B" PCAddShift [31:0] $end
$upscope $end
$scope module programCounter $end
$var wire 32 C" PCNext [31:0] $end
$var wire 1 B clock $end
$var wire 1 C reset $end
$var reg 32 D" outPCNext [31:0] $end
$upscope $end
$scope module registerMem $end
$var wire 1 B clk $end
$var wire 32 E" dataWrite [31:0] $end
$var wire 1 i rWrite $end
$var wire 1 C reset $end
$var wire 5 F" rs1 [4:0] $end
$var wire 5 G" rs2 [4:0] $end
$var wire 5 H" rsWrite [4:0] $end
$var reg 32 I" outRS1 [31:0] $end
$var reg 32 J" outRS2 [31:0] $end
$var reg 32 K" registerArray1 [31:0] $end
$var reg 32 L" registerArray10 [31:0] $end
$var reg 32 M" registerArray11 [31:0] $end
$var reg 32 N" registerArray12 [31:0] $end
$var reg 32 O" registerArray13 [31:0] $end
$var reg 32 P" registerArray14 [31:0] $end
$var reg 32 Q" registerArray15 [31:0] $end
$var reg 32 R" registerArray16 [31:0] $end
$var reg 32 S" registerArray17 [31:0] $end
$var reg 32 T" registerArray18 [31:0] $end
$var reg 32 U" registerArray19 [31:0] $end
$var reg 32 V" registerArray2 [31:0] $end
$var reg 32 W" registerArray20 [31:0] $end
$var reg 32 X" registerArray21 [31:0] $end
$var reg 32 Y" registerArray22 [31:0] $end
$var reg 32 Z" registerArray23 [31:0] $end
$var reg 32 [" registerArray24 [31:0] $end
$var reg 32 \" registerArray25 [31:0] $end
$var reg 32 ]" registerArray26 [31:0] $end
$var reg 32 ^" registerArray27 [31:0] $end
$var reg 32 _" registerArray28 [31:0] $end
$var reg 32 `" registerArray29 [31:0] $end
$var reg 32 a" registerArray3 [31:0] $end
$var reg 32 b" registerArray30 [31:0] $end
$var reg 32 c" registerArray31 [31:0] $end
$var reg 32 d" registerArray32 [31:0] $end
$var reg 32 e" registerArray4 [31:0] $end
$var reg 32 f" registerArray5 [31:0] $end
$var reg 32 g" registerArray6 [31:0] $end
$var reg 32 h" registerArray7 [31:0] $end
$var reg 32 i" registerArray8 [31:0] $end
$var reg 32 j" registerArray9 [31:0] $end
$upscope $end
$scope module sht $end
$var wire 32 k" immediate [31:0] $end
$var reg 32 l" shiftImmediate [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx l"
bx k"
bx j"
bx i"
bx h"
bx g"
bx f"
bx e"
bx d"
bx c"
bx b"
bx a"
bx `"
bx _"
bx ^"
bx ]"
bx \"
bx ["
bx Z"
bx Y"
bx X"
bx W"
bx V"
bx U"
bx T"
bx S"
bx R"
bx Q"
bx P"
bx O"
bx N"
bx M"
bx L"
bx K"
bx J"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
bx B"
bx A"
bx @"
bx ?"
bx >"
1="
x<"
bx ;"
bx :"
bx 9"
bx 8"
bx 7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
b0xxxxxxx -"
bx ,"
bx +"
bx *"
bx )"
bx ("
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
bx z
xy
bx x
bx w
bx v
bx u
bx t
xs
bx r
bx q
bx p
bx o
bx n
xm
xl
xk
bx j
xi
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
xG
bx F
bz E
bz D
0C
0B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#20000
b0 '
b0 O
b0 d"
b0 (
b0 P
b0 c"
b11111100 )
b11111100 Q
b11111100 b"
b0 +
b0 S
b0 `"
b0 ,
b0 T
b0 _"
b0 -
b0 U
b0 ^"
b0 .
b0 V
b0 ]"
b0 /
b0 W
b0 \"
b0 0
b0 X
b0 ["
b0 1
b0 Y
b0 Z"
b0 2
b0 Z
b0 Y"
b0 3
b0 [
b0 X"
b0 4
b0 \
b0 W"
b0 6
b0 ^
b0 U"
b0 7
b0 _
b0 T"
b0 8
b0 `
b0 S"
b0 9
b0 a
b0 R"
b0 :
b0 b
b0 Q"
b0 ;
b0 c
b0 P"
b0 <
b0 d
b0 O"
b0 =
b0 e
b0 N"
b0 >
b0 f
b0 M"
b0 ?
b0 g
b0 L"
b0 !
b0 I
b0 j"
b0 "
b0 J
b0 i"
b0 #
b0 K
b0 h"
b0 $
b0 L
b0 g"
b0 %
b0 M
b0 f"
b0 &
b0 N
b0 e"
b111 *
b111 R
b111 a"
b111 5
b111 ]
b111 V"
b0 @
b0 h
b0 K"
1B
#40000
0B
#60000
1B
#80000
0B
#100000
1B
#120000
0B
#140000
1B
#160000
0B
#180000
1B
#200000
0B
#220000
1B
#240000
0B
#260000
1B
#280000
0B
#300000
1B
#320000
0B
#340000
1B
#360000
0B
#380000
1B
#400000
0B
#420000
1B
#440000
0B
#460000
1B
#480000
0B
#500000
1B
#520000
0B
#540000
1B
#560000
0B
#580000
1B
#600000
0B
#620000
1B
#640000
0B
#660000
1B
#680000
0B
#700000
1B
#720000
0B
#740000
1B
#760000
0B
#780000
1B
#800000
0B
#820000
1B
#840000
0B
#860000
1B
#880000
0B
#900000
1B
#920000
0B
#940000
1B
#960000
0B
#980000
1B
#1000000
0B
